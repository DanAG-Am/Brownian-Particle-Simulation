# -*- coding: utf-8 -*-
"""BrownianMotion.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wdCop8Qt3R3CnXSDxD9IVIitssXrNWVG
"""

import random
import numpy as np
import matplotlib.pyplot as plt

# Number of particles
num_particles = 100
t = []

for i in range (num_particles):
  Z = np.concatenate((np.zeros ((10000, 1)),np.random.normal(0, 1,(10000, 251)).cumsum(axis=1)), axis=1)
  t.append(np.var(Z[:, -1],ddof=1))

plt.hist(t)

import random
import numpy as np
import matplotlib.pyplot as plt

# Number of particles
num_particles = 100
t = []

for i in range (num_particles):
  Z = np.concatenate((np.zeros ((10000, 1)),np.random.normal(0, 0.001,(10000, 251)).cumsum(axis=1)), axis=1)
  t.append(np.var(Z[:, -1],ddof=1))

plt.hist(t)

#Parametros que por ahora son predeterminados
dt = 0.1      # Time step
n = 20        # Number of iterations

# iniciar la posicion de los ejes
x = np.zeros(n)

# Extender a 3D Brownian motion
y = np.zeros(n)
z = np.zeros(n)

# generarla, donde se movera en una escala dada por el paso (tiempo) y por la particula que le antecede
x[1:] = x[:-1] + np.random.normal(scale=dt, size=n-1)

# mostrar la trajectoria
plt.plot(np.arange(n), x)
plt.xlabel("Time step")
plt.ylabel("Position")
plt.title("1D Brownian Motion")
plt.grid(True)
plt.show()

# extender a 3D
y[1:] = y[:-1] + np.random.normal(scale=dt, size=n-1)
z[1:] = z[:-1] + np.random.normal(scale=dt, size=n-1)

# Plot 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(x, y, z)
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_title("3D Brownian Motion")
plt.show()

"""https://www.youtube.com/watch?v=1XeA-fkjppY"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation

# Parametros
dt = 0.050      # Time step
n = 100       # Number of iterations
num_particles = 50  # Number of particles

# Posicion de varias particulas
x = np.zeros((num_particles, n))
y = np.zeros((num_particles, n))
z = np.zeros((num_particles, n))

# Crear la figura
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# en punto
scatter = [ax.scatter([], [], []) for _ in range(num_particles)]

# loop para la funcion, actualizando la posicion de las particulas
def update(frame):
    for i in range(num_particles):
        x[i, frame:] = x[i, :n-frame] + np.random.normal(scale=dt, size=n-frame)
        y[i, frame:] = y[i, :n-frame] + np.random.normal(scale=dt, size=n-frame)
        z[i, frame:] = z[i, :n-frame] + np.random.normal(scale=dt, size=n-frame)
        scatter[i]._offsets3d = (x[i, frame:], y[i, frame:], z[i, frame:])

         # limites
    ax.set_xlim(-0.20, 0.20)
    ax.set_ylim(-0.20, 0.20)
    ax.set_zlim(-0.20, 0.20)

    return scatter

# Crear animacion
ani = FuncAnimation(fig, update, frames=n, interval=70, blit=True)

ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_title("3D Brownian Motion")

# animacion
plt.show()

#Metodo indagado
import matplotlib.pyplot as plt
import numpy as np

T = []
k = 252
n = 10000

for j in range (n):
  B = [0]
  for i in range (k):
    B.append(B[-1] + np.random.normal(0,1))
  plt.plot(B)
  T.append(B[-1])

print(np.mean(T))
print(np.var(T, ddof=1))

plt.xlabel("p number")
plt.ylabel("Position")
plt.title("Brownian Motion")

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from IPython.display import display, clear_output
import time

# Parametros
dt = 0.35
n = 10


x = np.zeros(n)
y = np.zeros(n)
z = np.zeros(n)


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
line, = ax.plot([], [], [])


ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_title("Real-time 3D Brownian Motion")

def update_plot(num, x, y, z, line):
    line.set_data(x[:num-1], y[:num-1])
    line.set_3d_properties(z[:num-1])
    return line,


for i in range(1, n):
    x[i] = x[i - 1] + np.random.normal(scale=dt)
    y[i] = y[i - 1] + np.random.normal(scale=dt)
    z[i] = z[i - 1] + np.random.normal(scale=dt)

    line, = update_plot(i, x, y, z, line)

    clear_output(wait=True)
    display(fig)
    time.sleep(0.1)

    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_zlim(-1, 1)

plt.close()

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

#Generar coordenadas
rcx = [rand(-100, 100)]
rcy = [rand(-100, 100)]
rcz = [rand(-100, 100)]

# Coordenadas del punto de observacion
rpx = rand(-100, 100)
rpy = rand(-100, 100)
rpz = rand(-100, 100)

eps0 = 8.854e-12
k = 1 / (4 * math.pi * eps0)

# carga
q_values = [random.randint(0, 30) * 10**-12]

Ex = []
Ey = []
Ez = []

for i in range(len(rcx)):
    rx = rpx - rcx[i]
    ry = rpy - rcy[i]
    rz = rpz - rcz[i]

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    Ex.append(k * q_values[i] * rx / r**3)
    Ey.append(k * q_values[i] * ry / r**3)
    Ez.append(k * q_values[i] * rz / r**3)

Ex_total = sum(Ex)
Ey_total = sum(Ey)
Ez_total = sum(Ez)

# Magnitud
Magnitude = math.sqrt(Ex_total**2 + Ey_total**2 + Ez_total**2)

#Normalizar
Ex_normalized = Ex_total / Magnitude
Ey_normalized = Ey_total / Magnitude
Ez_normalized = Ez_total / Magnitude

# Plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

scale_factor = 100
Ex_arrow = Ex_normalized * scale_factor
Ey_arrow = Ey_normalized * scale_factor
Ez_arrow = Ez_normalized * scale_factor

ax.quiver(rpx, rpy, rpz, Ex_arrow, Ey_arrow, Ez_arrow, color='b', label='Electric Field')
ax.scatter(rcx, rcy, rcz, c='r', marker='o', label='Particles')
ax.scatter(rpx, rpy, rpz, c='g', marker='o', label='Observation Point')

ax.set_xlim([-150, 150])
ax.set_ylim([-150, 150])
ax.set_zlim([-150, 150])

ax.set_title('Electric Field Components (Ex, Ey, Ez) in 3D')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()

plt.show()

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

num_particles = 20
rcx = [rand(-100, 100) for _ in range(num_particles)]
rcy = [rand(-100, 100) for _ in range(num_particles)]
rcz = [rand(-100, 100) for _ in range(num_particles)]


rpx = rand(-100, 100)
rpy = rand(-100, 100)
rpz = rand(-100, 100)

eps0 = 8.854e-12
k = 1 / (4 * math.pi * eps0)

q_values = [random.randint(0, 30) * 10**-12 for _ in range(num_particles)]

Ex_total = 0
Ey_total = 0
Ez_total = 0

for i in range(num_particles):
    rx = rpx - rcx[i]
    ry = rpy - rcy[i]
    rz = rpz - rcz[i]

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    Ex_total += k * q_values[i] * rx / r**3
    Ey_total += k * q_values[i] * ry / r**3
    Ez_total += k * q_values[i] * rz / r**3

Magnitude = math.sqrt(Ex_total**2 + Ey_total**2 + Ez_total**2)

Ex_normalized = Ex_total / Magnitude
Ey_normalized = Ey_total / Magnitude
Ez_normalized = Ez_total / Magnitude

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

scale_factor = 100
Ex_arrow = Ex_normalized * scale_factor
Ey_arrow = Ey_normalized * scale_factor
Ez_arrow = Ez_normalized * scale_factor

ax.quiver(rpx, rpy, rpz, Ex_arrow, Ey_arrow, Ez_arrow, color='b', label='Electric Field')
ax.scatter(rcx, rcy, rcz, c='r', marker='o', label='Particles')
ax.scatter(rpx, rpy, rpz, c='g', marker='o', label='Observation Point')

ax.set_xlim([-150, 150])
ax.set_ylim([-150, 150])
ax.set_zlim([-150, 150])

ax.set_title('Electric Field Components (Ex, Ey, Ez) in 3D with Particle Interactions')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()

plt.show()

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

#Generar las particulas
num_particles_brownian = 20
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# posicion
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

eps0 = 8.854e-12
k = 1 / (4 * math.pi * eps0)

#carga
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

for i in range(num_particles_brownian):
    rx = rpx - x_brownian[i]
    ry = rpy - y_brownian[i]
    rz = rpz - z_brownian[i]

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    Ex_brownian[i] += k * q_values_brownian[i] * rx / r**3
    Ey_brownian[i] += k * q_values_brownian[i] * ry / r**3
    Ez_brownian[i] += k * q_values_brownian[i] * rz / r**3

Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

Ex_normalized_brownian = Ex_brownian / Magnitude_brownian
Ey_normalized_brownian = Ey_brownian / Magnitude_brownian
Ez_normalized_brownian = Ez_brownian / Magnitude_brownian

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

scale_factor_brownian = 0.05
Ex_arrow_brownian = Ex_normalized_brownian * scale_factor_brownian
Ey_arrow_brownian = Ey_normalized_brownian * scale_factor_brownian
Ez_arrow_brownian = Ez_normalized_brownian * scale_factor_brownian

ax.quiver(rpx, rpy, rpz, Ex_arrow_brownian, Ey_arrow_brownian, Ez_arrow_brownian, color='b', label='Electric Field')
ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')
ax.scatter(rpx, rpy, rpz, c='g', marker='o', label='Observation Point')

ax.set_xlim([-0.20, 0.20])
ax.set_ylim([-0.20, 0.20])
ax.set_zlim([-0.20, 0.20])

ax.set_title('Electric Field Components (Ex, Ey, Ez) in 3D with Brownian Motion')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()

update(0)

ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")
ax.set_title("3D Brownian Motion with Electric Field Components")

plt.show()

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20    # Number of iterations

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    Ex = k * q * rx / r**3
    Ey = k * q * ry / r**3
    Ez = k * q * rz / r**3

    return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 20
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

for i in range(num_particles_brownian):
    rx = rpx - x_brownian[i]
    ry = rpy - y_brownian[i]
    rz = rpz - z_brownian[i]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[i])

    Ex_brownian[i] += coulomb_force[0]
    Ey_brownian[i] += coulomb_force[1]
    Ez_brownian[i] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = Ex_brownian / Magnitude_brownian
Ey_normalized_brownian = Ey_brownian / Magnitude_brownian
Ez_normalized_brownian = Ez_brownian / Magnitude_brownian

# Initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.array([0.0, 0.0, 0.0])  # Initial velocity

# Arrays to store position and velocity
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Compute deterministic force and extend to 3D Brownian motion
x_deterministic = np.zeros(n)
y_deterministic = np.zeros(n)
z_deterministic = np.zeros(n)

x_deterministic[1:] = x_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)
y_deterministic[1:] = y_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)
z_deterministic[1:] = z_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)

# Compute final positions and velocities
for t in range(n):
    Fstochastic = np.array([np.random.normal(scale=1) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()]))/m * dt + Fdeterministic/m * dt
    ri = ri + vf[t] * dt
    rf[t] = ri

    # Update initial position and velocity for the next iteration
    vi = vf[t]
    ri = rf[t]

# Plotting
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')

# Plot deterministic force trajectory
ax.plot(x_deterministic, y_deterministic, z_deterministic, label='Deterministic Force Trajectory')

# Plot final position of observing particle
ax.plot(rf[:, 0], rf[:, 1], rf[:, 2], label='Final Position')
ax.scatter(rf[0, 0], rf[0, 1], rf[0, 2], c='g', marker='o', label='Initial Position')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Final Position of Observing Particle with Brownian Motion and Deterministic Force')

plt.show()

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20    # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    Ex = k * q * rx / r**3
    Ey = k * q * ry / r**3
    Ez = k * q * rz / r**3

    return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 20
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

for i in range(num_particles_brownian):
    rx = rpx - x_brownian[i]
    ry = rpy - y_brownian[i]
    rz = rpz - z_brownian[i]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[i])

    Ex_brownian[i] += coulomb_force[0]
    Ey_brownian[i] += coulomb_force[1]
    Ez_brownian[i] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = Ex_brownian / Magnitude_brownian
Ey_normalized_brownian = Ey_brownian / Magnitude_brownian
Ez_normalized_brownian = Ez_brownian / Magnitude_brownian

# Initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.array([0.0, 0.0, 0.0])  # Initial velocity

# Arrays to store position and velocity
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Compute deterministic force and extend to 3D Brownian motion
x_deterministic = np.zeros(n)
y_deterministic = np.zeros(n)
z_deterministic = np.zeros(n)

x_deterministic[1:] = x_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)
y_deterministic[1:] = y_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)
z_deterministic[1:] = z_deterministic[:-1] + np.random.normal(scale=dt, size=n-1)

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')

# Plot deterministic force trajectory
line_deterministic, = ax.plot(x_deterministic, y_deterministic, z_deterministic, c='b', label='Deterministic Force Trajectory')

# Plot initial and final positions of observing particle
scatter_initial = ax.scatter(ri[0], ri[1], ri[2], c='g', marker='o', label='Initial Position')
scatter_final = ax.scatter([], [], [], c='m', marker='o', label='Final Position')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize ri and vf arrays
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vf = np.zeros((n, 3))  # Final velocities

# Animation function
def animate(t):
    global ri  # Declare ri as global

    Fstochastic = np.array([np.random.normal(scale=1) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()]))/m * dt + Fdeterministic/m * dt
    ri = ri + vf[t] * dt
    rf[t] = ri

    # Update particles and trajectory plot
    scatter_brownian._offsets3d = (x_brownian, y_brownian, z_brownian)
    line_deterministic.set_data(x_deterministic[:t+1], y_deterministic[:t+1])
    line_deterministic.set_3d_properties(z_deterministic[:t+1])

    scatter_initial._offsets3d = ([ri[0]], [ri[1]], [ri[2]])  # Update initial position
    scatter_final._offsets3d = ([rf[t, 0]], [rf[t, 1]], [rf[t, 2]])  # Update final position

    return scatter_brownian, line_deterministic, scatter_initial, scatter_final

# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)
ax.set_xlim(-0.20, 0.20)
ax.set_ylim(-0.20, 0.20)
ax.set_zlim(-0.20, 0.20)


# Display animation
HTML(ani.to_jshtml())

"""numba
herramientas ngit

https://codereview.stackexchange.com/questions/249992/simulating-brownian-motion-for-n-particles
"""

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20  # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    if r == 0:
        return np.array([0, 0, 0])  # Avoid division by zero
    else:
        Ex = k * q * rx / r**3
        Ey = k * q * ry / r**3
        Ez = k * q * rz / r**3

        return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 5
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

# Initialize arrays to store electric field components for Brownian particles
Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

# Initialize arrays to store final positions and velocities
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Calculate electric field components for Brownian particles at the observation point
for t in range(num_particles_brownian):
    rx = rpx - x_brownian[t]
    ry = rpy - y_brownian[t]
    rz = rpz - z_brownian[t]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[t])

    Ex_brownian[t] += coulomb_force[0]
    Ey_brownian[t] += coulomb_force[1]
    Ez_brownian[t] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = np.divide(Ex_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ex_brownian), where=Magnitude_brownian!=0)
Ey_normalized_brownian = np.divide(Ey_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ey_brownian), where=Magnitude_brownian!=0)
Ez_normalized_brownian = np.divide(Ez_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ez_brownian), where=Magnitude_brownian!=0)

# Generate deterministic force trajectories for Brownian motion
x_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
y_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
z_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')


ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.zeros(3)  # Initial velocity

# Animation function
def animate(t):
    global ri, vf  # Declare global variables

    Fstochastic = np.array([np.random.normal(scale=np.sqrt(dt)) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()])) / m * dt + Fdeterministic / m * dt
    ri = ri + vf[t] * dt
    rf[t] = ri

    # Update particles and position plots
    scatter_brownian._offsets3d = (np.array(x_brownian) + ri[0], np.array(y_brownian) + ri[1], np.array(z_brownian) + ri[2])
    scatter_initial._offsets3d = ([ri[0]], [ri[1]], [ri[2]])  # Update initial position
    scatter_final._offsets3d = ([rf[t, 0]], [rf[t, 1]], [rf[t, 2]])  # Update final position

    # Return a sequence of artistic objects to update
    return scatter_brownian, scatter_initial, scatter_final

# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)

# Display animation
HTML(ani.to_jshtml())

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20  # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    if r == 0:
        return np.array([0, 0, 0])  # Avoid division by zero
    else:
        Ex = k * q * rx / r**3
        Ey = k * q * ry / r**3
        Ez = k * q * rz / r**3

        return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 5
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

# Initialize arrays to store electric field components for Brownian particles
Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

# Initialize arrays to store final positions and velocities
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Calculate electric field components for Brownian particles at the observation point
for t in range(num_particles_brownian):
    rx = rpx - x_brownian[t]
    ry = rpy - y_brownian[t]
    rz = rpz - z_brownian[t]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[t])

    Ex_brownian[t] += coulomb_force[0]
    Ey_brownian[t] += coulomb_force[1]
    Ez_brownian[t] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = np.divide(Ex_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ex_brownian), where=Magnitude_brownian!=0)
Ey_normalized_brownian = np.divide(Ey_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ey_brownian), where=Magnitude_brownian!=0)
Ez_normalized_brownian = np.divide(Ez_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ez_brownian), where=Magnitude_brownian!=0)

# Generate deterministic force trajectories for Brownian motion
x_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
y_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
z_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
colors = ['r' for _ in range(num_particles_brownian)]  # Initially all particles are red
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c=colors, marker='o', label='Brownian Particles')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.zeros(3)  # Initial velocity

# Animation function
def animate(t):
    global ri, vf, x_brownian  # Declare global variables

    Fstochastic = np.array([np.random.normal(scale=np.sqrt(dt)) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()])) / m * dt + Fdeterministic / m * dt
    ri = ri + vf[t] * dt

    # Wrap particles around the box when they leave or enter
    for i in range(num_particles_brownian):
        if ri[0] + x_brownian[i] > 0.15:
            x_brownian[i] -= 0.3
        elif ri[0] + x_brownian[i] < -0.15:
            x_brownian[i] += 0.3

            # Adjust the entering particle position to enter at the same x-coordinate from which the leaving particle exited
            x_brownian[i] += np.sign(x_brownian[i]) * 0.3

        if ri[1] + y_brownian[i] > 0.15:
            y_brownian[i] -= 0.3
        elif ri[1] + y_brownian[i] < -0.15:
            y_brownian[i] += 0.3

        if ri[2] + z_brownian[i] > 0.15:
            z_brownian[i] -= 0.3
        elif ri[2] + z_brownian[i] < -0.15:
            z_brownian[i] += 0.3

    # Update the scatter plot
    scatter_brownian._offsets3d = (x_brownian + ri[0], y_brownian + ri[1], z_brownian + ri[2])

    # Return a sequence of artistic objects to update
    return scatter_brownian,

# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)

# Display animation
HTML(ani.to_jshtml())

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20  # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    if r == 0:
        return np.array([0, 0, 0])  # Avoid division by zero
    else:
        Ex = k * q * rx / r**3
        Ey = k * q * ry / r**3
        Ez = k * q * rz / r**3

        return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 5
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

# Initialize arrays to store electric field components for Brownian particles
Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

# Initialize arrays to store final positions and velocities
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Calculate electric field components for Brownian particles at the observation point
for t in range(num_particles_brownian):
    rx = rpx - x_brownian[t]
    ry = rpy - y_brownian[t]
    rz = rpz - z_brownian[t]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[t])

    Ex_brownian[t] += coulomb_force[0]
    Ey_brownian[t] += coulomb_force[1]
    Ez_brownian[t] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = np.divide(Ex_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ex_brownian), where=Magnitude_brownian!=0)
Ey_normalized_brownian = np.divide(Ey_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ey_brownian), where=Magnitude_brownian!=0)
Ez_normalized_brownian = np.divide(Ez_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ez_brownian), where=Magnitude_brownian!=0)

# Generate deterministic force trajectories for Brownian motion
x_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
y_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
z_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.zeros(3)  # Initial velocity

# Animation function
def animate(t):
    global ri, vf, x_brownian, rpx  # Declare global variables

    Fstochastic = np.array([np.random.normal(scale=np.sqrt(dt)) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()])) / m * dt + Fdeterministic / m * dt
    ri = ri + vf[t] * dt

    # Apply periodic boundary conditions for a box of size 0.3
    ri = np.mod(ri, 0.3)

    # Update particles and position plots
    scatter_brownian._offsets3d = (np.array(x_brownian) + ri[0], np.array(y_brownian) + ri[1], np.array(z_brownian) + ri[2])

    # Replace particles leaving the box with new particles entering from the opposite side
    for i in range(num_particles_brownian):
        if x_brownian[i] > 0.15 and ri[0] < 0.15:
            x_brownian[i] -= 0.3
        elif x_brownian[i] < -0.15 and ri[0] > -0.15:
            x_brownian[i] += 0.3

        # Update observation point position based on box displacement
        if rpx > 0.15 and ri[0] < 0.15:
            rpx -= 0.3
        elif rpx < -0.15 and ri[0] > -0.15:
            rpx += 0.3

    # Return a sequence of artistic objects to update
    return scatter_brownian,

# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)
ax.set_xlim(-0.20, 0.20)
ax.set_ylim(-0.20, 0.20)
ax.set_zlim(-0.20, 0.20)


# Display animation
HTML(ani.to_jshtml())

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 20  # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 1 / (4 * math.pi * eps0)

    r = math.sqrt(rx**2 + ry**2 + rz**2)
    if r == 0:
        return np.array([0, 0, 0])  # Avoid division by zero
    else:
        Ex = k * q * rx / r**3
        Ey = k * q * ry / r**3
        Ez = k * q * rz / r**3

        return np.array([Ex, Ey, Ez])

# Generate random particle positions for Brownian motion
num_particles_brownian = 5
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

# Initialize arrays to store electric field components for Brownian particles
Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

# Initialize arrays to store final positions and velocities
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities

# Calculate electric field components for Brownian particles at the observation point
for t in range(num_particles_brownian):
    rx = rpx - x_brownian[t]
    ry = rpy - y_brownian[t]
    rz = rpz - z_brownian[t]

    coulomb_force = get_coulomb_force(rx, ry, rz, q_values_brownian[t])

    Ex_brownian[t] += coulomb_force[0]
    Ey_brownian[t] += coulomb_force[1]
    Ez_brownian[t] += coulomb_force[2]

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = np.divide(Ex_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ex_brownian), where=Magnitude_brownian!=0)
Ey_normalized_brownian = np.divide(Ey_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ey_brownian), where=Magnitude_brownian!=0)
Ez_normalized_brownian = np.divide(Ez_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ez_brownian), where=Magnitude_brownian!=0)

# Generate deterministic force trajectories for Brownian motion
x_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
y_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
z_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Plot Brownian particles
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c='r', marker='o', label='Brownian Particles')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.zeros(3)  # Initial velocity

# Animation function
def animate(t):
    global ri, vf, x_brownian, rpx  # Declare global variables

    Fstochastic = np.array([np.random.normal(scale=np.sqrt(dt)) for _ in range(3)])  # Stochastic force vector
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])  # Deterministic force vector

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()])) / m * dt + Fdeterministic / m * dt
    ri = ri + vf[t] * dt

    # Apply periodic boundary conditions for a box of size 0.3
    ri = np.mod(ri, 0.3)

    # Update particles and position plots
    scatter_brownian._offsets3d = (np.array(x_brownian) + ri[0], np.array(y_brownian) + ri[1], np.array(z_brownian) + ri[2])

    # Replace particles leaving the box with new particles entering from the opposite side
    for i in range(num_particles_brownian):
        if x_brownian[i] > 0.15 and ri[0] < 0.15:
            x_brownian[i] -= 0.3
        elif x_brownian[i] < -0.15 and ri[0] > -0.15:
            x_brownian[i] += 0.3

        # Update observation point position based on box displacement
        if rpx > 0.15 and ri[0] < 0.15:
            rpx -= 0.3
        elif rpx < -0.15 and ri[0] > -0.15:
            rpx += 0.3

        # Add entering particles with random positions
        if x_brownian[i] < -0.15 and ri[0] < -0.15:
            x_brownian[i] = rand(-0.15, -0.05)
            y_brownian[i] = rand(-0.15, 0.15)
            z_brownian[i] = rand(-0.15, 0.15)

    # Return a sequence of artistic objects to update
    return scatter_brownian,

# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)
ax.set_xlim(-0.20, 0.20)
ax.set_ylim(-0.20, 0.20)
ax.set_zlim(-0.20, 0.20)
# Display animation
HTML(ani.to_jshtml())

import random
import math
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
from matplotlib import animation
from IPython.display import HTML
from numba import njit, prange

def rand(minimum, maximum):
    return minimum + (maximum - minimum) * random.random()

# Parameters
dt = 0.1  # Time step
n = 100  # Number of iterations
m = 1     # Mass (assuming unity for simplicity)

@njit(parallel=True)
def get_coulomb_force(rx, ry, rz, q):
    eps0 = 8.854e-12
    k = 0
    return np.array([0, 0, 0])  # Avoid division by zero

# Generate random particle positions for Brownian motion
num_particles_brownian = 100
x_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
y_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]
z_brownian = [rand(-0.15, 0.15) for _ in range(num_particles_brownian)]

# Random position for the observation point
rpx = rand(-0.15, 0.15)
rpy = rand(-0.15, 0.15)
rpz = rand(-0.15, 0.15)

# Random charge for each Brownian particle (between 0 and 30 pC)
q_values_brownian = [random.randint(0, 30) * 10**-12 for _ in range(num_particles_brownian)]

# Initialize arrays to store electric field components for Brownian particles
Ex_brownian = np.zeros(num_particles_brownian)
Ey_brownian = np.zeros(num_particles_brownian)
Ez_brownian = np.zeros(num_particles_brownian)

# Calculate electric field components for Brownian particles at the observation point
@njit(parallel=True)
def get_coulomb_force(rx, ry, rz, q):

        return np.array([0.0, 0.0, 0.0])

# Calculate the magnitude of the electric field vector for Brownian particles
Magnitude_brownian = np.sqrt(Ex_brownian**2 + Ey_brownian**2 + Ez_brownian**2)

# Normalize the electric field vectors for Brownian particles
Ex_normalized_brownian = np.divide(Ex_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ex_brownian), where=Magnitude_brownian!=0)
Ey_normalized_brownian = np.divide(Ey_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ey_brownian), where=Magnitude_brownian!=0)
Ez_normalized_brownian = np.divide(Ez_brownian, Magnitude_brownian,
                                   out=np.zeros_like(Ez_brownian), where=Magnitude_brownian!=0)

# Generate deterministic force trajectories for Brownian motion
x_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
y_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))
z_deterministic = np.cumsum(np.random.normal(scale=dt, size=n))

# Create 3D plot
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

# Generate random colors for each Brownian particle
colors = [np.random.rand(3,) for _ in range(num_particles_brownian)]

# Plot Brownian particle with different colors
scatter_brownian = ax.scatter(x_brownian, y_brownian, z_brownian, c=colors, marker='o', label='Brownian Particles')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend()
ax.set_title('Brownian Motion and Deterministic Force')

# Initialize initial position and velocity
ri = np.array([0.0, 0.0, 0.0])  # Initial position
vi = np.zeros(3)  # Initial velocity

# Initialize arrays to store final positions and velocities
rf = np.zeros((n, 3))  # Final positions
vf = np.zeros((n, 3))  # Final velocities


# Animation function
def animate(t):
    global ri, vf, x_brownian, y_brownian, z_brownian

    Fstochastic = np.array([np.random.normal(scale=np.sqrt(dt)) for _ in range(3)])  # Stochastic force vector

    # Initialize the deterministic force for each particle separately
    Fdeterministic = np.array([x_deterministic[t], y_deterministic[t], z_deterministic[t]])

    vf[t] = vi + (Fstochastic + np.array([Ex_normalized_brownian.sum(), Ey_normalized_brownian.sum(), Ez_normalized_brownian.sum()])) / m * dt + Fdeterministic / m * dt
    ri = ri + vf[t] * dt

    # Wrap particles around the box when they leave or enter
    for i in range(num_particles_brownian):
        if ri[0] + x_brownian[i] > 0.15:
            x_brownian[i] -= 0.3
        elif ri[0] + x_brownian[i] < -0.15:
            x_brownian[i] += 0.3
            x_brownian[i] += np.sign(x_brownian[i]) * 0.3

        if ri[1] + y_brownian[i] > 0.15:
            y_brownian[i] -= 0.3
        elif ri[1] + y_brownian[i] < -0.15:
            y_brownian[i] += 0.3

        if ri[2] + z_brownian[i] > 0.15:
            z_brownian[i] -= 0.3
        elif ri[2] + z_brownian[i] < -0.15:
            z_brownian[i] += 0.3

    # Update the scatter plot
    scatter_brownian._offsets3d = (x_brownian + ri[0], y_brownian + ri[1], z_brownian + ri[2])

    return scatter_brownian,


# Create animation
ani = animation.FuncAnimation(fig, animate, frames=n, interval=100, blit=True)

# Display animation
HTML(ani.to_jshtml())